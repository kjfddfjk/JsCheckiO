#!/usr/bin/env checkio --domain=js run ulam-warburton-automaton

// 
// 
// This mission is dedicated to theUlamâ€“Warburton cellular automaton (UWCA)- a 2-dimensional fractal pattern that grows on a regular grid of cells consisting of squares.
// 
// Starting with one square initially ON and all others OFF, successive iterations are generated by turning ON all squares that share precisely one edge with an ON square.
// 
// This pattern is shown among others (so I recommend you to watch it all) in the following video with Neil Sloane (founder of theOn-Line Encyclopedia of Integer Sequences) starting from the 8.10.
// 
// 
// 
// Theplaygroundof this and other patterns may be seen on thepage. It will be easier to solve the task and it's just a beautiful hypnotic view!)
// 
// So, your function must return the number of activated cells after given number of steps.
// 
// Input:Number of steps as Number.
// 
// Output:Number of cells as Number.
// 
// Examples:
// 
// assert.strictEqual(automaton(1), 1);
// assert.strictEqual(automaton(2), 5);
// assert.strictEqual(automaton(3), 9);
// assert.strictEqual(automaton(4), 21);
// 
// END_DESC

import assert from "assert";

function automaton(step: number): number {
    const arr: boolean[][] = new Array(step * 2 + 1).fill(false).map(() => new Array(step * 2 + 1).fill(false));
    const nextArr: boolean[][] = new Array(step * 2 + 1).fill(false).map(() => new Array(step * 2 + 1).fill(false));
    arr[step][step ] = true;
    nextArr[step][step ] = true;
    for(let currentStep = 1; currentStep < step; currentStep++) {
        arr.forEach((row, i) => {
            row.forEach((_, j) => {
                if(_) {
                    return;
                }
                const count = (i - 1 >= 0 && arr[i - 1][j] ? 1 : 0)
                                + (j - 1 >= 0 && arr[i][j - 1] ? 1 : 0)
                                + (i + 1 < arr.length && arr[i + 1][j] ? 1 : 0)
                                + (j + 1 < arr[0].length && arr[i][j + 1] ? 1 : 0);
                if (count === 1) {
                    nextArr[i][j] = true;
                }
            });
        });
        // clone nextArr to arr
        nextArr.forEach((row, i) => {
            row.forEach((current, j) => {
                arr[i][j] = current;
            });
        });
    }

    return arr.reduce((sum, row) => {
        return sum + row.reduce((rowSum, present) => {
            return rowSum + (present ? 1 : 0);
        }, 0);
    }, 0);
}

console.log("Example:");
console.log(automaton(2));

// These "asserts" are used for self-checking
assert.strictEqual(automaton(1), 1);
assert.strictEqual(automaton(2), 5);
assert.strictEqual(automaton(3), 9);
assert.strictEqual(automaton(4), 21);
assert.strictEqual(automaton(5), 25);

console.log("Coding complete? Click 'Check Solution' to earn rewards!");